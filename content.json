{"meta":{"title":"IT and life","subtitle":"","description":"","author":"Sang","url":"https://fs-sournary.github.io","root":"/"},"pages":[{"title":"About","date":"2020-06-28T01:38:39.000Z","updated":"2020-07-03T00:01:01.025Z","comments":false,"path":"about/index.html","permalink":"https://fs-sournary.github.io/about/index.html","excerpt":"","text":"Khi xưa mình cũng học 1 trường công nghệ thông tin (dấu tí) tại Việt Nam nhưng do quá tự màn vì thành tích có được nên đã làm nhiều thứ vô bổ (dấu tí). Mình không hối hận về quãng thời gian đó vì nó cho mình nhiều trải nghiệm và suy ngẫm. Trong quá trình trở lại, mình cũng đã gặp nhiều may mắn được nhiều người tốt giúp đỡ. Tính ra tuổi nghề của mình cũng còn khá ít (không sao), hiện tại mình đang có nhiều ý định bao gồm cả lập trình. Hiện tại mình đang là Android developer ở công ty Sun-asterisk Việt Nam. Mình lập trang web này cho mọi người nhằm chia sẻ cho mọi người những kiến thức mình đã học hỏi được. Trong những bài viết, chắc chắn sẽ có những sai sót mong mọi người bỏ qua và góp ý cho mọi người. Kiến thức lập trình rất rộng lớn, mỗi người một định hướng nhưng hãy cứ từ từ tiến bước học hỏi dần dần thì sẽ đến đích. Chúc mọi người thành công trên con đường lập trình của mình. Có một câu mà mình chiêm nghiệm ra là Kỹ thuật học sâu không khó chỉ cần bạn kiên nhẫn thôi"},{"title":"Categories","date":"2020-06-28T00:59:32.000Z","updated":"2020-06-28T01:34:19.618Z","comments":false,"path":"categories/index.html","permalink":"https://fs-sournary.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-06-28T01:30:20.000Z","updated":"2020-06-28T01:34:00.824Z","comments":false,"path":"tags/index.html","permalink":"https://fs-sournary.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Tìm hiểu về complexity analysis","slug":"complexity-analysis","date":"2020-07-08T08:42:21.000Z","updated":"2020-07-11T00:20:00.929Z","comments":false,"path":"2020/07/08/complexity-analysis/","link":"","permalink":"https://fs-sournary.github.io/2020/07/08/complexity-analysis/","excerpt":"","text":"I, Mở đầu Hằng ngày, chúng ta phải đối mặt với nhiều vấn đề. Mỗi vấn đề chúng ta có thể nghĩ ra nhiều phương án để giải quyết. Chúng ta đều mong muốn chọn ra phương án hiệu quả nhất. Ví dụ như khi đi từ nhà tới nơi làm việc, có thể biết được rất nhiều con đường nhưng chúng ta chỉ muốn đi con đường ngắn nhất để tiết kiệm thời gian và nhiên liệu. Trong lập trình cũng như thế, khi đối mặt với một vấn đề, các developer cũng sẽ tạo ra các giải thuật khác nhau để giải quyết vấn đề đó. Điều quan trọng vẫn là tìm ra và sử dụng giải thuật tối ưu nhất. II, Giải thuật Ví dụ 1: giải thuật của bài toán tìm tổng của 2 số a và b có thể bao gồm các bước sau: Bước 1: Tạo ra biến result để lưu kết quả của a + b. Bước 2: Trả về biến result. 1234fun sun(int a, int b)&#123; int result = a + b; return result;&#125; Khi giải quyết 1 vấn đề trong lập trình, chúng ta cần xác định các yếu tố: input, giải thuật và output: Input: là dữ liệu đầu vào được xác định từ bài toán. Chúng ta cần chuyển những dữ liệu đầu vào (input) thành kết quả mong muốn (output). Trong ví dụ 1, input là a và b. Giải thuật: là tập hợp các bước biến đổi dữ liệu đầu vào (input) thành kết quả mong muốn (output). Trong ví dụ 1, giải thuật gồm 2 bước. Output: là kết quả mong muốn của bài toán. Trong ví dụ 1, output là result. Giải một bài toán trong lập trình tương tự như tạo ra một sản phẩm: từ nguyên liệu thô (input) qua các công đoạn để tạo ra sản phẩm mong muốn (output). Việc chọn ra giải thuật hiệu quả sẽ giúp tiết kiệm thời gian và tài nguyên của chương trình. Một giải thuật hiệu quả cần có những yếu tố sau: Đúng đắn: với các input đầu vào, giải thuật phải cho ra output đúng theo yêu cầu. Nếu tồn tại ít nhất một output không đúng yêu cầu thì giải thuật đó là sai. Giới hạn: đây cũng là 1 yếu tố quan trọng nhưng mọi người thường bỏ qua nó. Giải thuật phải được kết thúc sau một tập các bước xác định. Ví dụ như khi chúng ta tìm kiếm phần tử k trong vòng lặp có n phàn tử, khi tìm thấy phần tử k chúng ta phải dừng tìm kiếm ngay để tránh việc thực thi các thao tác sau không cần thiết. Hiệu quả: chúng ta luôn muốn chọn ra giải thuật hiệu quả nhất cho code. Trong lập trình, sự hiệu quả của giải thuật thường được đánh giá bởi hai yếu tố là bộ nhớ và thời gian. III, Độ phức tạp của giải thuật Như mình đã nói ở trên, độ hiệu quả của thuật toán phụ thuộc vào hai yếu tố là bộ nhớ và thời gian. Do đó chúng ta luôn mong muốn tìm ra 1 thuật toán tiêu tốn ít bộ nhớ và thời gian. Nhưng việc này gần như là không thể. Trong giải thuật, bộ nhớ và thời gian là hai thái cực đối lập với nhau. Nếu giải thuật tiêu tốn ít thời gian thì nó sẽ cần nhiều bộ nhớ và ngược lại. Hiện nay bộ nhớ gần như không phải là vấn đề để giải quyết vấn đề, do đó người ta thường chú ý nhiều hơn vào yếu tố thời gian. Mình cũng sẽ đi sâu vào yếu tố thời gian của 1 giải thuật. 1, Bộ nhớ Mỗi giải thuật cần được cấp 1 lượng bộ nhớ nhất định để hoàn thành. Ví dụ 2: chúng ta tạo 1 mảng chứa 20 phần tử. Space complexity dựa vào số phần tử của mảng. Nếu số lượng phần tử tăng lên (21, 22…phần tử) thì bộ nhớ yêu cầu sẽ tăng lên. 1int intArray[] = new int[20]; // allocating memory to array Trong lập trình, ngay cả khỉ bạn tạo ra 1 object thì chúng ta cũng cần cấp phát bộ nhớ cho nó. 2, Thời gian Thời gian thực hiện các tác vụ (số thao tác) của 1 giải thuật được phân tích dựa vào kích thước dữ liệu. Giải thuật hiệu quả nhất là giải thuật có thời gian thực hiện ít nhất. Chú ý: quy ước rằng mỗi thao tác sẽ có thời gian thực hiện giống nhau. IV, Phân tích thời gian Chúng ta sử dụng asymptotic notation để phân tích và dựa vào kích thước của dữ liệu để đưa độ hiệu quả của giải thuật. Trong phân tích với asymptotic notation, chúng ta xử lý với các kích thước dữ liệu lớn. Asymptotic notation sẽ chỉ quan tâm tới order of growth của input. Trong order of growth, chúng ta chỉ sử dụng giới hạn lớn nhất vì các giới hạn thấp hơn không đáng kể với kích thước dữ liệu lớn. Điều này có nghĩa khi chúng ta tăng/giảm kích thước dữ liệu thì thời gian tính của giải thuật sẽ tăng/giảm như thế nào. Chúng ta có 3 asymptotic notation để mô tả thời gian tính của thuật toán: &#937; notation (Big omega). &#920; notation (Big theta). &#927; notation (Big omicron). Ví dụ 3: function search() kiểm tra số k có trong mảng arr. Nếu k nằm trong arr thì function sẽ trả về 1, còn không thì sẽ trả về 0. Phân tích bài toán, chúng ta có: Input: mảng arr có n phần tử và số k. Output: trả về 1 nếu k là 1 phần tử của arr còn không sẽ trả về 0. Giải thuật: chúng ta có thể sử dụng linear search được trình bày như sau: 123456int search(int arr[], int n, int k)&#123; for(int i = 0, i &lt; n; i++)&#123; if(arr[i] == k) return 1; &#125; return 0;&#125; Trong function search(), các câu lệnh được thực hiện số lần là: i = 0: 1 lần. i &lt; n: n + 1 lần. i++: n lần. arr[i] == k: i lần tuỳ thuộc vào k. return 1: nhiều nhất 1 lần. return 0: nhiều nhất 1 lần. Chúng ta có thể nhận ra rằng khi tăng k (thay đổi kích thước dữ liệu) thì thời gian thực hiện giải thuật cũng tăng. Nếu ta có arr[] = [0, 1, 2, 3, 4] thì với: k = 0: arr[i] == k thực hiện 1 lần. k = 2: arr[i] == k thực hiện 3 lần. k &gt;= 4: arr[i] == k thực hiện 5 lần. Từ đó chúng ta có các khái niệm nói về các trường hợp có thể xảy ra của 1 giải thuật: Best case: (trường hợp tốt nhất) trường hợp có thời gian thực hiện giải thuật là ít nhất. Trong ví dụ 3, best case xảy ra khi k = 0. Average case: (trường hợp trung gian) chúng ta thử với tất cả input type để tìm ra số lần thực hiện với mỗi kiểu input. Sau đó, chúng ta cộng lại tất cả và chia số kiểu input. Worst case (trường hợp tệ nhất) trường hợp có thời gian thực hiện giải thuật là nhiều nhất. Trong ví dụ 3, worst case xảy ra khi k &gt;= 4. 1, &#937; notation (Big omega) &#937; notation nói đến tiệm cận dưới trong giải thuật. &#937; được áp dụng cho best case. &#937;(g(n)) = { f(n) nếu tồn tại các hằng số dương c and n0 sao cho 0 ≤ c.g(n) ≤ f(n) với mọi n ≥ n0 } Ta nói g(n) là cận dưới tiệm cần của f(n). 2, &#920; notation (Big theta) &#920; nói đến tiệm cần đúng trong giải thuật. &#920; định nghĩa ra 1 giới hạn trên và giới hạn dưới cho giải thuật. &#937; được áp dụng cho average case. &#920;(g(n)) = { f(n) nếu tồn tại các hằng số dương c1, c2 and n0 sao cho 0 ≤ c1.g(n) ≤ f(n) ≤ c2.g(n) với mọi n ≥ n0 }} Ta nói g(n) là đánh giá tiệm cận đúng cho f(n). 3, &#927; notation (Big omicron) &#927; nói đến tiệm cần trên trong giải thuật. &#927; được áp dụng cho worst case. &#927;(g(n)) = { f(n) nếu tồn tại 2 hằng số dương c and n0 sao cho 0 ≤ f(n) ≤ c.g(n) với mọi n ≥ n0 } Ta nói g(n) là cận trên tiệm cận của f(n). V, Ví dụ qua bài toán tính tổng Bài toán: Tìm tổng của dãy n phần tử liền kề nhau bắt đầu từ 1 và cách nhau 1 đơn vị. Dãy có dạng là 1, 2, 3, 4..., n-1, n. Khi n = 4 thì kết quả là 1 + 2 + 3 + 4 = 10. Khi n = 5 thì kết quả là 1 + 2 + 3 + 4 + 5 = 15. … 1, Giải pháp &#927;(1)123int findSum(int n) &#123; return n * (n+1) / 2; // this will take some constant time c1&#125; Chúng ta có duy nhất một câu lệnh. Với mọi kích thước dữ liệu (n = 1, 2, 3…), chúng ta chỉ mất một khoảng thời gian cố định để thực hiện câu lệnh đó. Do đó chúng ta có thời gian tính của thuật toán trong worst case là &#927;(1). 2, Giải pháp &#927;(n)123456int findSum(int n) &#123; int sum = 0; for(int i = 1; i &lt;= n; ++i) sum = sum + i; return sum;&#125; Tổng thời gian thực hiện các câu lệnh sum = 0, i = 1 và return sum là c0 (hằng số). Thời gian thực hiện câu lệnh i &lt;= n là c1 (hằng số). Chúng ta thực hiện n lần i &lt;= n nên tổng thời gian cần để thực hiện c1.n. Thời gian thực hiện câu lệnh sum = sum + i là c2 (hằng số). Chúng ta thực hiện n lần sum = sum + i nên tổng thời gian cần để thực hiện c2.n. Tổng thời gian thực hiện các câu lệnh là c1.n + c2.n + c0 hay (c1 + c2).n + c0. Do đó chúng ta chỉ sử dụng giới hạn lớn nhất nên thời gian tính của thuật toán trong worst case sẽ là &#927;(n). 3, Giải pháp &#927;(n²)1234567int findSum(int n) &#123; int sum = 0; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= i; ++j) sum++; return sum;&#125; Tổng thời gian thực hiện các câu lệnh sum = 0, i = 1, j = 1 và return sum là c0 (hằng số). Thời gian thực hiện câu lệnh i &lt;= n là c1 (hằng số). Chúng ta thực hiện n lần i &lt;= n nên tổng thời gian thực hiên là c1.n. Thời gian thực hiện câu lệnh j &lt;= i là c2 (hằng số). Chúng ta thực hiện n.(n + 1)/2 lần j &lt;= i do đó tổng thời gian thực hiện làn.(n + 1)/2.c2. Tương tự với câu lệnh sum++ thì tổng thời gian thực hiện là n.(n + 1)/2.c3. Do đó thời gian tính của thuật toán trong worst case là &#927;(n²). Mọi người tự tính và lấy giới hạn lớn nhất nhé.","categories":[],"tags":[{"name":"Cấu trúc dữ liệu và giải thuật","slug":"Cau-truc-du-lieu-va-giai-thuat","permalink":"https://fs-sournary.github.io/tags/Cau-truc-du-lieu-va-giai-thuat/"}]},{"title":"Tìm hiểu về kotlin DSL","slug":"kotlin-dsl","date":"2020-07-05T00:42:50.000Z","updated":"2020-07-06T04:10:31.619Z","comments":false,"path":"2020/07/05/kotlin-dsl/","link":"","permalink":"https://fs-sournary.github.io/2020/07/05/kotlin-dsl/","excerpt":"","text":"I, DSL là gì Wikipedia định nghĩa DSL như sau: A domain-specific language (DSL) is a computer language specialized to a particular application domain. This is in contrast to a general-purpose language (GPL), which is broadly applicable across domains Đói với các developer, DSL cung cấp các tool để đơn giản hoá việc thực hiện các cấu trúc phức tạp bằng cách tận dụng các tool sẵn có của ngôn ngữ lập trình. Trong Kotlin, chúng ta cũng đã sử dụng rất nhiều kotlin DSL. Hàm forEach() cũng là 1 Kotlin DSL: 123listOf(1, 2, 3).forEach &#123; //...&#125; II, Kotlin DSL Trước khi tìm hiểu về Kotlin DSL, bạn nên biết trước về high-order function và function literal với receiver. Nếu bạn đã sẵn sàng thì chúng ta bắt đầu tìm hiểu về kotlin DSL 1, Tạo Kotlin DSL Để hiểu rõ hơn, chúng ta sẽ đi xem xét ví dụ sau: 123456789fun getResult(a: Int, b: Int, action: Int.(Int) -&gt; Int): Int &#123; return action(a, b)&#125;fun main()&#123; val text = getResult(1, 2)&#123; this + it &#125; // Result: 3&#125; Function getResult() có 3 parameter, trong đó action có kiểu là function type với receiver. Do đó action cần được khởi tạo bởi function literal với receiver như ở main(). Trên đây là ví dụ để xây dựng nên Kotlin DSL. Kotlin xây dựng sẵn cho chúng ta một số library sử dụng Kotlin DSL: Tạo ra markup code như HTML, XML. Làm việc với UI component: Anko. Cấu hình route cho web server: Ktor 2, Sử dụng infix keyword Chúng ta có thể thêm infix keyword cho function. Khi đó tên của function được gọi là infix notation, chúng ta có thể gọi function sử dụng infix notion (bỏ qua . và ()). Các infix function cần tuân thủ: Chúng phải là member function hoặc extension function. Chúng chỉ có 1 paramter không có default value (vararg không được chấp nhận ). Ví dụ 1: sử dụng infix với extension function 12345infix fun Int.plus(other: Int): Int = this + other1 plus 2 // ok1.plus(2) // okplus(1, 2) // ok Ví dụ 2: sử dụng infix với member function, khi sử dụng infix notation bắt buộc phải có this keyword. 123456789class MyStringCollection &#123; infix fun add(s: String) &#123; /*...*/ &#125; fun build() &#123; this add \"abc\" // Correct add(\"abc\") // Correct //add \"abc\" // Incorrect: the receiver must be specified &#125;&#125;","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"}]},{"title":"Tìm hiểu về sealed class trong kotlin","slug":"saled-class-in-kotlin","date":"2020-07-04T14:24:29.000Z","updated":"2020-07-04T21:50:55.735Z","comments":false,"path":"2020/07/04/saled-class-in-kotlin/","link":"","permalink":"https://fs-sournary.github.io/2020/07/04/saled-class-in-kotlin/","excerpt":"","text":"I, Sealed class Sealed được dịch ra là khép kín. Do đó sealed class hiểu nôm na là class khép kín. Trong kotlin, sealed class được sử dụng để giới hạn hệ thống class: variable của sealed class chỉ có thể ở trong 1 tập giới hạn (có vẻ giống với enum class). Về mặt ý nghĩa, sealed class là phần mở rộng của enum class. Đồng thời, sealed class cũng là abstract class (mặc dù không có abstract keyword). Do đó chúng không thể được khởi tạo sealed class và sealed class thể chứa abstract member. II, Sealed class vs enum class Như mình đã nói ở trên, sealded class là phần mở rộng của enum class do đó nó sẽ tốt hơn enum class. Giống nhau: Variable của sealed class hay enum class đều bị giới hạn ở 1 tập nhất định. Khác nhau: Các enum constant chỉ có 1 kiểu khai báo (giống với enum class) và tồn tại như 1 instance của enum class. Các enum constant chỉ có thể nằm trong body của enum class. Sealed class có thể có subclass. Các subclass của sealed class có thể khai báo theo nhiều cách khác nhau. Các subclass phải được khai báo cùng file với sealed class. Ví dụ 1: 1234567891011// Enumenum class State(val message: String) &#123; SUCCESS(\"Success\"), ERROR(val exception: Exception) // not possible with enums&#125;// Sealed class and its subclassessealed class Exprdata class Const(val number: Double) : Expr()class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr() III, Sealed class vs abstract class Bản thân sealed class chính là abstract class nên nó có thể có subclass và abstract member. Subclass của abstract class có thể khai báo ở bất cứ đâu (dựa vào cả visibility modifier). Subclass của sealed class chỉ có thể được khai báo cùng file với nó. Sealed class cũng chỉ có private constructor. Mặc định nếu không khai báo constructor thì nó là private. Chú ý: class extend subclass của sealed class có thể được khai báo ở bất cứ đâu. Lợi ích lớn nhất của sealed class so với abstract class là khi sử dụng điều kiện when: khi chúng ta cover hết tất cả trường hợp thì không cần mệnh đề else nữa. Ví dụ 2: kết hợp với ví dụ 1 123456fun eval(expr: Expr): Double = when(expr) &#123; is Const -&gt; expr.number is Sum -&gt; eval(expr.e1) + eval(expr.e2) NotANumber -&gt; Double.NaN // the `else` clause is not required because we've covered all the cases&#125;","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"}]},{"title":"Tìm hiểu về inline function trong kotlin","slug":"inline-noninline-and-crossiinline-in-kotlin","date":"2020-07-04T04:11:39.000Z","updated":"2020-07-04T11:19:53.320Z","comments":false,"path":"2020/07/04/inline-noninline-and-crossiinline-in-kotlin/","link":"","permalink":"https://fs-sournary.github.io/2020/07/04/inline-noninline-and-crossiinline-in-kotlin/","excerpt":"","text":"I, Inline function1, Vấn đề Trước khi đọc bài viết này, mình khuyên bạn nên đọc về high-order function trước. High-order function gặp vấn đề là mỗi parameter có function type cần được khởi tạo bằng 1 function object trong memory và tạo ra runtime overhead. Ví dụ 1: 123456789101112131415class InlineExample &#123; // Test with anonymous function fun testAnonymous() &#123; makeHighOrder(fun() = 1) &#125; // Test with lambada function fun testLambada() &#123; makeHighOrder &#123; 1 &#125; &#125; private fun makeHighOrder(action: () -&gt; Int) &#123; action() &#125;&#125; Khi chúng ta dùng xem nó được compile qua java code bằng Tools &gt; Kotlin &gt; Show kotlin bytecode &gt; Decompile, chúng ta sẽ thấy class InlineExample.java 12345678910111213public final class InlineExample &#123; public final void testAnonymous() &#123; this.makeHighOrder((Function0)null.INSTANCE); &#125; public final void testLambada() &#123; this.makeHighOrder((Function0)null.INSTANCE); &#125; private final void makeHighOrder(Function0 action) &#123; action.invoke(); &#125;&#125; Ta có thể thấy makeHighOrder() trong InlineExample.java có 1 tham số action có kiểu Function0. Khi nó được sử dụng ở testAnonymous() và testLambada() thì sẽ tạo ra 2 object Function0. Trong kotlin, chúng ta không tạo ra đối tượng nào cả ? Đây cũng là vấn đề của high-order function. 2, Inline function Ví dụ 2: tương tự như ví dụ 1 nhưng mình sẽ thêm inline keyword vào trước makeHighOrder() 12345678910111213141516class InlineExample &#123; // Test with anonymous function fun testAnonymous() &#123; makeHighOrder(fun() = 1) &#125; // Test with lambada function fun testLambada() &#123; makeHighOrder &#123; 1 &#125; &#125; // Add `inline` keyword private inline fun makeHighOrder(action: () -&gt; Int) &#123; action() &#125;&#125; Khi đó, InlineExample sẽ được compile sang java code như sau 12345678910111213141516public final class InlineExample &#123; public final void testAnonymous() &#123; int $i$f$makeHighOrder = false; boolean var3 = false; &#125; public final void testLambada() &#123; int $i$f$makeHighOrder = false; boolean var3 = false; &#125; private final void makeHighOrder(Function0 action) &#123; int $i$f$makeHighOrder = 0; action.invoke(); &#125;&#125; Mặc dù makeHighOrder() vẫn được compile gần giống như cũ. Nhưng khi gọi testAnonymous() và testLambada() nhưng không tạo ra Function0 nào nữa. Có chuyện gì xảy ra khi ta sử dụng inline function ? Từ khóa inline đã copy implement của function vào nơi gọi function (call-site) đó. Do đó các call-site không tạo ra bất cứ object nào. Chú ý: Inline function được dùng để tối ưu cho high-order function. Nếu bạn thêm inline vào những function thông thường sẽ không có ý nghĩa về mặt tối ưu. Android studio sẽ có warning và suggest bạn bỏ inline đi. 12// No performance impact. We will get warning hereinline fun test(a: Int)&#123;&#125; 3, Giới hạn và cách dùng inline function Nhược điểm của inline function mà chúng ta có thể thấy ngay là chúng có thể gây ra nhiều code thừa vì implement của nó có thể dùng ở nhiều nơi. Inline function dùng ở đâu ? Chúng ta nên tránh sử dụng inline cho những function lớn. Chúng ta nên inline cho những function nhỏ (vài ba dòng). Nếu bạn xem source code của file _Collections.kt thì bạn sẽ thấy các inline function chỉ có từ 1 đến 3 dòng. II, Noinline Inline function không cho phép parameter có function type: Gán cho 1 local variable. Truyền vào trong function khác ở body. Ví dụ 3: 123456789101112private inline fun makeHighOrder( action: () -&gt; Int, notInline: () -&gt; Unit) &#123; action() val t = notInline // Compilation error makeNotInline(notInline) // Compilation error&#125;fun makeNotInline(notInline: () -&gt; Unit)&#123;&#125; Trong trường hợp này, chúng ta có thể đánh dấu notInline bằng từ khoá noinline như ví dụ 4. Ví dụ 4: sửa error ở ví dụ 3 123456789101112private inline fun makeHighOrder( action: () -&gt; Int, noinline notInline: () -&gt; Unit) &#123; action() val t = notInline // It is ok because of `noinline` makeNotInline(notInline) // It is ok because of `noinline`&#125;fun makeNotInline(notInline: () -&gt; Unit) &#123;&#125; Khi sử dụng noinline cho biến notInline thì khi khởi tạo notInline lại tạo ra object trong bộ nhớ.","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"}]},{"title":"Tìm hiểu về high-order function trong kotlin","slug":"high-order-function-in-kotlin","date":"2020-07-03T08:47:59.000Z","updated":"2020-01-01T06:30:46.276Z","comments":false,"path":"2020/07/03/high-order-function-in-kotlin/","link":"","permalink":"https://fs-sournary.github.io/2020/07/03/high-order-function-in-kotlin/","excerpt":"","text":"I, High-order function Các kotlin function đều là first class: nó có thể trở thành kiểu dữ liệu cho variable, tham số hơặc kết quả return của high-order function. Ta gọi đó là function type (kiểu dữ liệu function). High-order function là function lấy function khác làm tham số hoặc trả về 1 function. Chú ý: high-order function sẽ khiến tạo thêm các function type object trong memory. Do đó để tối ưu bộ nhớ, chúng ta có thể sử dụng inline function. Để hiểu rõ hơn, chúng ta sẽ đi phân tích high-order function fold(): Ví dụ 1: 12345inline fun &lt;T, R&gt; Iterable&lt;T&gt;.fold(initial: R, operation: (R, T) -&gt; R): R &#123; var accumulator = initial for (element in this) accumulator = operation(accumulator, element) return accumulator&#125; Hàm fold() nhận 2 tham số: 1, initial: có kiểu là R 2, operation: có kiểu là (R, T) -&gt; R ? (R, T) -&gt; R là 1 function type. Do đó nó cũng có thể là kiểu dữ liệu của tham số operation trong high-order function fold(). Ta có (R, T) -&gt; R định nghĩa cho 1 function type có: 1, Hai tham số là với kiểu dữ liệu là R và T. 2, Giá trị trả về có kiểu dữ liệu là R. II, Function types Ở ví dụ 1, (R, T) -&gt; R là function type nên nó cũng như các kiểu dữ liệu thông thường khác: val operation: (R, T) -&gt; R = ... Khi sử dụng function type, bạn cần chú ý: 1, Function type đều có: danh sách kiểu dữ liệu các tham số và kiểu dữ liệu của giá trị trả về. Ví dụ (A, B) -&gt; C có 2 tham số với kiểu dữ liệu lần lượt là A, B và kiểu dữ liệu của giá trị trả về là C. 2, Danh sách kiểu dữ liệu của tham số có thể rỗng như () -&gt; A. Kiểu của dữ liệu trả về phải được xác định dù đó có là Unit. 3, Function type có thể có thêm kiểu dữ liệu của receiver. Ví dụ A.(B) -&gt; C có kiểu dữ liệu của receiver là A, kiểu dữ liệu của tham số là B và kiểu dữ liệu của giá trị trả về là C. 4, Function type có thể null, bạn chỉ cần thêm ()? vào nguyên mẫu. Ví dụ ((A, B) -&gt; C)?. 5, Suspending function là function có kiểu dữ liệu function đặc biệt (mình sẽ nói về công cụ tuyệt vời này sau), bạn phải thêm suspend keyword: suspend () -&gt; A, suspend A.(B) -&gt; C. Chú ý: chúng ta có thể thêm tên cho các tham số như (x: Int, y: Int) -&gt; Point. Nó giúp bạn cho bạn viết document thuận tiện hơn. Ví dụ 2: chúng ta thêm tên cho các tham số cho kiểu dữ liệu của operation trong hàm fold() ở ví dụ 1 1234// It's ok to name for `R` type with `acc`.inline fun &lt;T, R&gt; Iterable&lt;T&gt;.fold(initial: R, operation: (acc: R, T) -&gt; R): R &#123; ...&#125; Ví dụ 3: kiểu dữ liệu function nhận thêm receiver thì this đại diện cho receiver. 123456789101112// Only one parameter in the function type so `it` is implicitly used.val sum1: Int.(String) -&gt; Int = &#123; print(this) print(it) 4&#125;// Two parameter in the function type so we must explicitly specify name of two. val sum: Int.(String, String) -&gt; Int = &#123; s1, s2 -&gt; // ... 4&#125; III, Khởi tạo kiểu function type Để tạo ra 1 instance của function type, chúng ta có thể sử dụng: function literal hoặc callable reference. Ngoài ra còn có cách khác là tạo custom class implement kiểu dữ liệu function như 1 interface. Bạn phải override invoke(). 1, Function literal Function literal bao gồm có: Lambada expression có dạng {a, b -&gt; a + b} Anonymous function có dạng fun(s: String): Int { return s.toIntOrNull() ?: 0 }. Ví dụ 4: 1234val list = listOf(1, 2, 3, 4)list.filter &#123; item -&gt; item &gt; 2 &#125; // using lambada// Orlist.filter(fun(item) = item &gt; 2) // using anonymous function 2, Callable reference Các callable reference đều thêm :: vào trước định danh của chúng. Kiểu dữ liệu funtion có thể được khởi tạo với Callable reference bao gồm: function reference có dạng ::isOdd, String::toInt property reference có dạng ::x, List&lt;Int&gt;::size constructor reference có dạng ::Foo Ví dụ 5: sử dụng function reference khởi tạo function type in ra kết quả [1, 3] 123456fun isOdd(x: Int) = x % 2 != 0fun main() &#123; val numbers = listOf(1, 2, 3) print(numbers.filter(::isOdd))&#125; Ví dụ 6: sử dụng property reference khởi tạo function type in ra kết quả [1, 2, 3] 1234fun main() &#123; val strs = listOf(\"a\", \"bc\", \"def\") println(strs.map(String::length))&#125; Ví dụ 7: sử dụng constructor reference khởi tạo function type. Nó gọi constructor của Foo class trong để khởi tạo factory 1234567class Foofun test(factory: () -&gt; Foo) &#123; val x: Foo = factory()&#125;test(::Foo) III, Sử dụng variable của function type Chúng ta có thể gọi variable f có kiểu dữ liệu function bằng: Thông qua invoke() là f.invoke(). Gọi trực tiếp là f() Nếu f có thể null thì ta chỉ dùng được f?.invoke() Đối với function type có receiver, chúng ta xem ví dụ 8. Ví dụ 8: 1234567891011val stringPlus: (String, String) -&gt; String = String::plusval intPlus: Int.(Int) -&gt; Int = Int::plusprintln(stringPlus.invoke(\"&lt;-\", \"-&gt;\"))// Orprintln(stringPlus(\"Hello, \", \"world!\"))// Function type with receiver.println(intPlus.invoke(1, 1))println(intPlus(1, 2))println(2.intPlus(3)) // extension-like call IV, Function literal với receiver Như trên mình có nói rõ, function type có thể được khởi tạo bởi function literal (labamda expression hoặc anonymous function). Do đó, function type có receiver A.(B) -&gt; C có thể được khởi tạo bằng function literal với recevier. Nói cách khác, lambada expression hay anonymous function sẽ nhận this keyword đại diện cho receiver object. Ví dụ 9: this đại diện cho receiver object nên plus() là 1 function được gọi bởi receiver object. 1234567// Using lambada expressionval sum1: Int.(Int) -&gt; Int = &#123; other -&gt; plus(other) &#125;// Orval sum2: Int.(Int) -&gt; Int = &#123; other -&gt; this.plus(other) &#125;// Using anonymous function. It allows you to specify receiver type.val sum = fun Int.(other: Int): Int = this + other","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"}]},{"title":"Tìm hiểu về labels và jump expression trong Kotlin","slug":"labels-and-jump-expression-in-kotlin","date":"2020-07-03T07:25:59.000Z","updated":"2020-07-04T12:03:21.481Z","comments":false,"path":"2020/07/03/labels-and-jump-expression-in-kotlin/","link":"","permalink":"https://fs-sournary.github.io/2020/07/03/labels-and-jump-expression-in-kotlin/","excerpt":"","text":"I, Label Trong Kotlin, bất cứ expression nào đều có thể được đánh dấu bằng label. Label được tạo nên từ định danh của label và @ như abc@, lit@, forTest@… Để đặt label lên 1 expression, chúng ta chỉ cần đặt label trước expression đó. Ví dụ 1: đặt loop@ label cho vòng lặp for 123loop@ for (i in 1..100) &#123; // ...&#125; II, Jump expression Kotlin cung cấp 3 jump expression: 1, return: mặc định nó sẽ return function gần nhất hoặc return anonymous function. 2, break: kết thúc vòng lập gần nhất. 3, continue: thực hiện bước tiếp theo của vòng lặp gần nhất. 1, Break và continue Ví dụ 2: khi i = 5, vòng lặp sẽ kết thúc bằng việc sử dụng break. 1234loop@ for (i in 1..9) &#123; if (i == 5) break@loop print(i) // result: 1234&#125; Ví dụ 3: khi i = 5, sẽ không in ra 5 bởi vì continue nhảy đến step tiếp theo trong for. 1234loop@ for (i in 1..9) &#123; if (i == 5) continue@loop print(i) // result: 12346789. Don't have 5 because `continue` jumps to next step.&#125; 2, return Các local function (function trong function khác), object expression và lambada có thể lồng nhau. Mặc định giống với Java, return sẽ return function gần nó nhất hoặc anonymous function. Một tác dụng quan trọng của return là dùng để return 1 lambada. Khi tạo function có parameter được khởi tạo bởi lambada, label sẽ trùng với tên của funtion. Trong lambada, Kotlin chỉ cho phép: return với label: return lambada đó. return không có label nếu lambada ở trong inline function: return function ngoài gần nó nhất. Tham khảo bài viết về inline function để hiểu rõ hơn vấn đề này. Ví dụ 4: Do forEach() là inline function nên return kết thúc hàm gần nó nhất là foo() 123456789fun foo() &#123; listOf(1, 2, 3, 4, 5).forEach &#123; if (it == 3) return // non-local return directly to the caller of foo() print(it) &#125; println(\"this point is unreachable\")&#125;// Result: 1, 2 Ví dụ 5: đặt lit@ label cho lambada của forEach() hoặc kotlin cũng đã sinh ra sẵn forEach label trùng với tên của function. 123456789fun foo() &#123; listOf(1, 2, 3, 4, 5).forEach lit@&#123; if (it == 3) return@lit // local return to the caller of the lambda, i.e. the forEach loop print(it) &#125; print(\" done with explicit label\")&#125;// Result: 1245 done with implicit label Ví dụ 6: 12345678910fun makeLabel(action: () -&gt; Unit)&#123; action()&#125;fun run()&#123; makeLabel &#123; print(\"Label\") return@makeLabel &#125;&#125; Chúng ta không thể dùng break và continue trong lambada. Ví dụ 7: chúng ta muốn dừng việc lặp của listOf(1, 2, 3, 4, 5) khi item nó bằng 3 và vẫn muốn tiếp tục code của foo() 1234567891011fun foo() &#123; run loop@&#123; listOf(1, 2, 3, 4, 5).forEach &#123; if (it == 3) return@loop // non-local return from the lambda passed to run print(it) &#125; &#125; print(\" done with nested loop\")&#125;// Result: 12 done with nested loop","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"}]},{"title":"So sánh Array và Collection trong Kotlin","slug":"array-vs-collection-in-kotlin","date":"2020-07-03T02:34:16.000Z","updated":"2020-07-03T22:54:47.316Z","comments":false,"path":"2020/07/03/array-vs-collection-in-kotlin/","link":"","permalink":"https://fs-sournary.github.io/2020/07/03/array-vs-collection-in-kotlin/","excerpt":"","text":"I, Array1234567891011public class Array&lt;T&gt; &#123; public inline constructor(size: Int, init: (Int) -&gt; T) public operator fun get(index: Int): T public operator fun set(index: Int, value: T): Unit public val size: Int public operator fun iterator(): Iterator&lt;T&gt;&#125; Array&lt;T&gt; là class chứa một mảng các phần tử T. Để tạo 1 array, chúng ta có thể sử dụng: 1, arrayOf(): tạo ra 1 array và mỗi phần tử không được phép null. 2, arrayOfNulls(): tạo ra 1 array các phần tử và cho phép phần tử null. 3, Array(): tạo ra một mảng với kích thước cố định và khởi tạo giá trị ban đầu cho từng phần tử. Chú ý: Array không phải là 1 phần của Collection. Ví dụ 1: 1234val array = arrayOf(1, 2, 3)// Creates an Array&lt;String&gt; with values [\"0\", \"1\", \"4\", \"9\", \"16\"]val asc = Array(5) &#123; i -&gt; (i * i).toString() &#125; Đối với primitive object type, Kotlin cung cấp sẵn các class để tạo ra array: ByteArray, CharArray, ShortArray, IntArray, LongArray, FloatArray, DoubleArray và BooleanArray. Chúng không có quan hệ gì với Array&lt;T&gt; class cả. II, Collection Chúng ta thường nhầm lẫn rằng Array là 1 phần của Collection. Điều này là không đúng. Collection là một tập hợp các Object cùng kiểu. Mỗi object trong collection được gọi là phần tử / element / item. Collection có 3 kiểu cơ bản: 1, List: là 1 tập hợp có thứ tự và mỗi item được truy cập thông qua chỉ số (vị trí). Chỉ số là các số integer. Một item có thể xuất hiện nhiều hơn 1 lần trong List (chỉ số khác nhau). 2, Set: là 1 tập hợp các item mà mỗi item là duy nhất. Các element không được lặp lại do đó nó có thể chứa duy nhất 1 null item. Trong Set, thứ tự các item là không quan trọng. 3, Map (dictionary): 1 tập các item có dạng key/value. Key là duy nhất dùng để phân biệt các item, value có thể được lặp lại. Trong mỗi kiểu cơ bản chúng ta có thể chia nó làm 2 dạng: 1, Read-only: chỉ cho phép truy cập tới các item. 2, Mutable: read-only + khả năng write: add, remove và update. Chúng ta có thể xem source code của các collection trong file Collections.kt List và Set đều kế implement Collection interface. Tuy Map không implement Collection nhưng nó vẫn là 1 kiểu của collection.","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"}]},{"title":"Tìm hiểu về scope function trong Kotlin","slug":"scope-function-in-kotlin","date":"2020-07-03T00:30:54.000Z","updated":"2020-07-03T22:55:46.241Z","comments":false,"path":"2020/07/03/scope-function-in-kotlin/","link":"","permalink":"https://fs-sournary.github.io/2020/07/03/scope-function-in-kotlin/","excerpt":"","text":"I, Scope function Kotlin standard library cung cấp Scope function với mục đích duy nhất là xử lý 1 đoạn code trong context của object. Scope function lấy tham số là 1 function của 1 object. Khi sử dụng, chúng ta có thể: 1, thay thế function đó bằng cách truyền vào lambada expression. 2, truy cập vào object của function mà không cần định nghĩa name cho nó. Kotlin cung cấp cho 5 loại scope function là let, run, with, apply và also. II, Phân biệt Các loại scope function khác nhau ở 2 điểm: 1, Object reference trong lambada function: this (lambada receiver) hay it (lambada argument). 2, Giá trị trả về: context object hay lambada result. Bảng phân biệt các scope function: Scope function Object reference Return value is extension function ? apply this context object Yes also it context object Yes let it lambada result Yes run this lambada result Yes run No this or it lambada result No: called without the context object. with this lambada result No: take context object as an argument Ví dụ 1: sử dụng apply, also và let 12345678910111213141516// `apply` use `this` as object referenceval applyPerson: Person = Person(\"Adam\").apply &#123; age = 32 &#125;// `also` use `it` as object referenceval alsoPerson: Person = Person(\"Adam\").also &#123; it.age = 32 &#125;// `let` use `it` as object referenceval letPerson = Person(\"Adam\")val age: Int = letPerson.let &#123; it.age = 32 it.age // return value is last expression&#125; Ví dụ 2: sử dụng run (run có 2 version) 12345678910111213// `run` version 1: use `this` as object referenceval runPerson = Person(\"Adam\", 32)val age: Int = runPerson.run &#123; age // return value is last expression&#125;println(\"Age is $age\") // result: Age is 32// `run` version 2: called without object reference. It doesn't have `this` or `it`val text = run &#123; val str = \"It life\" str&#125;println(text) // result: str Ví dụ 3: sử dụng with 12345val numbers = mutableListOf(\"one\", \"two\", \"three\")val firstAndLast = with(numbers) &#123; \"First: $&#123;first()&#125;,\" + \" Last: $&#123;last()&#125;\"&#125;println(firstAndLast) // result: First: one, Last: three Chú ý: Mặc dù, scope function làm cho code ngắn gọn hơn trong hầu hết trường hợp nhưng chúng có thể làm cho code khó đọc và dẫn tới error.Do đó chúng ta nên tránh lồng các scope function vâo với nhau và cần thận khi nối chúng với nhau.","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"}]},{"title":"Tìm hiểu về data class trong Kotlin","slug":"data-class-in-kotlin","date":"2020-07-02T22:07:38.000Z","updated":"2020-07-03T22:54:55.305Z","comments":false,"path":"2020/07/03/data-class-in-kotlin/","link":"","permalink":"https://fs-sournary.github.io/2020/07/03/data-class-in-kotlin/","excerpt":"","text":"I, Data class Chúng ta thường xuyên tạo các class với mục đích chính là xử lý data. Ở những class như vậy, chúng ta cần thiết phải implement 1 số phương thức liên quan tới data. Ví dụ 1: ở Java, việc này hoàn toàn làm bằng tay và khá dài dòng 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class User &#123; private String name; private int age; public Data(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; if (age != user.age) return false; return name != null ? user.equals(user.name) : user.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? user.hashCode() : 0; result = 31 * result + age; return result; &#125; @Override public String toString() &#123; return \"Data&#123;\" + \"name=\" + name + \", age=\" + age + '&#125;'; &#125;&#125; Kotlin cung cấp cho chúng ta data class để những class được tạo có mục đích chính là nắm giữ data. Bạn chỉ cần thêm data keyword vào trước class trong khai báo 1 class. Ví dụ 2: data class sẽ implement đầy đủ các phương thức hơn so với ví dụ 1 1data class User(val name: String, val age: Int) Compiler sẽ tự động compile để implement các function dựa trên các property được khai báo ở primary constructor: 1, equals(), hashCode(). 2, toString() với định dạng &quot;User(name=John, age=42)&quot;. 3, ComponentN() để get các property dựa trên thứ tự sắp xếp của chúng như val name: String = person.component1(), val age: Int = person.component2(). 4, copy() (mình sẽ nói rõ hơn ở III). Data class cũng cần phải tuân thủ các quy định sau: 1, Primary constructor cần ít nhất 1 parameter. 2, Tất cả parameter của primary constructor phải được sử dụng với val hoặc var. 3, Data class không thể là abstract, open, sealed hoặc inner class (static nested class vãn được nhé). II, Property ở body class Ở trên mình nói nhiều đến parameter ở trong primary constructor, nhưng nếu bạn khai báo property trong body class thì sao ? Chỉ có các paramter ở trong primary constructor được sử dụng cho equals(), hashCode(), toString(), copy() và componentN(). Ví dụ 3: chỉ có name parameter được sử dụng và chỉ có 1 method component1() được sinh ra. 12345678910111213data class Person(val name: String) &#123; var age: Int = 0&#125;fun main() &#123; val person1 = Person(\"John\") val person2 = Person(\"John\") person1.age = 10 person2.age = 20 println(\"person1 == person2: $&#123;person1 == person2&#125;\") // return true println(\"person1 with age $&#123;person1.age&#125;: $&#123;person1&#125;\") // person1 with age 10: Person(name=John) println(\"person2 with age $&#123;person2.age&#125;: $&#123;person2&#125;\") // person2 with age 20: Person(name=John)&#125; Do age không được sử dụng, do đó nếu 2 variable Person có age khác nhau nhưng name bằng nhau thì 2 variable Person vẫn bằng nhau. III, Copy() Phương thức copy() được sử dụng nếu bạn muốn tạo ra 1 Object mới: 1, có cùng type. 2, Object mới copy 1 vài parameter(các paramter không đổi) hoặc copy tất cả. Ví dụ 4: class Person ở ví dụ 2 implement copy() như sau: 1234567data class User(val name: String, val age: Int)&#123; fun copy(name: String = this.name, age: Int = this.age) = User(name, age)&#125;val itLife = User(name = \"IT life\", age = 20)val copyIt = itLife.copy(age = 20) IV, Standard data class Standard library cung cấp 2 data class là Pair và Triple. Ví dụ 5: xem source code của Pair và Triple trong Tuples.kt 123456789101112131415161718// `Pair` data classpublic data class Pair&lt;out A, out B&gt;( public val first: A , public val second: B) : Serializable &#123; public override fun toString(): String = \"($first, $second)\"&#125;// `Triple` data classpublic data class Triple&lt;out A, out B, out C&gt;( public val first: A, public val second: B, public val third: C) : Serializable &#123; public override fun toString(): String = \"($first, $second, $third)\"&#125;","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"}]},{"title":"Tìm hiểu về visibility modifier trong kotlin","slug":"visibility-modifier-in-kotlin","date":"2020-07-02T10:12:08.000Z","updated":"2020-07-03T22:56:10.591Z","comments":false,"path":"2020/07/02/visibility-modifier-in-kotlin/","link":"","permalink":"https://fs-sournary.github.io/2020/07/02/visibility-modifier-in-kotlin/","excerpt":"","text":"I, Mở đầu Trong Kotlin, class, object class, interface, constructor, function, property và custom setter của property đều có visibility modifier (custom getter luôn có visiblity modifier giống với property). Kotlin cung cấp 4 visibility modifier: private, protected, internal và public (mặc định). Chúng sẽ được áp dụng vào các scope khác nhau trong project. II, Package Function, property, class, object class, interface đều có thể là top-level member. Ví dụ 1: 1234567// file name: example.ktpackage fooconst val topLevelProperty = 1fun makeTopLevelFunction() &#123; ... &#125;class TopLevelClass &#123; ... &#125;object TopLevelObject &#123; ... &#125; Trong 1 package, các visibility modifier có nhiệm vụ: private: các member chỉ visible ở trong file khai báo chúng. protected: không được sử dụng cho việc khai báo top-level member. internal: các member chỉ visible trong với các member khác trong cùng module. public: các member sẽ visible ở tất cả mọi nơi. II, Class và interface Đối với các visibility modifỉer member được khai báo trong 1 class: private: các member chỉ visible ở trong class và các member khác (có thể là function, inner class). protected: private + visible trong subclass của nó. internal: các member chỉ visible trong với các member khác trong cùng module. public: các member sẽ visible ở tất cả mọi nơi. Nếu bạn override protected member ở subclass và không xác định visibility modifier, member bị override sẽ có visibility modifier là protected (không phải là public). Ví dụ 2: 123456789101112131415161718192021222324252627open class Outer &#123; private val a = 1 protected open val b = 2 protected open val b1 = 3 internal val c = 3 val d = 4 // public by default protected class Nested &#123; public val e: Int = 5 &#125;&#125;class Subclass : Outer() &#123; // a is not visible // b, c and d are visible // Nested and e are visible override val b = 5 // 'b' is protected public override val b1 = 6 // must specify explicitly with the protected member of the parent.&#125;class Unrelated(o: Outer) &#123; // o.a, o.b are not visible // o.c and o.d are visible (same module) // Outer.Nested is not visible, and Nested::e is not visible either &#125; III, Constructor Kotlin không cho phép constructor sử dụng protect. Để xác định visiblity modifier cho constructor, chúng ta thêm nó vào trước constructor keyword. Ví dụ 3: 1234567class A private constructor(a: Int) &#123; ... &#125;class B protected constructor() &#123; ... &#125; // Compilation errorsclass C internal constructor()&#123; ...&#125;class D ()&#123; ... &#125; // same with `public constructor()` IV, Local variable Local variable là những variable được khai báo bên trong 1 function. Nó chỉ visible bên trong function và các member của function đó. Kotlin không cho phép local variable có visiblity modifier vì nó không có ý nghĩa gì cả.","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"}]},{"title":"Tìm hiểu về lateinit và lazy trong Kotlin","slug":"lateinit-vs-lazy-in-kotlin","date":"2020-07-02T03:46:09.000Z","updated":"2020-07-03T22:55:29.467Z","comments":false,"path":"2020/07/02/lateinit-vs-lazy-in-kotlin/","link":"","permalink":"https://fs-sournary.github.io/2020/07/02/lateinit-vs-lazy-in-kotlin/","excerpt":"","text":"I, Late-initialized variable Thông thường, trong kotlin các non-null member variable phải được khởi tạo khi khai báo. Tuy nhiên, trong nhiều trường hợp điều này không thuận tiện. Kotlin cungx cho phép member variable khởi tạo sau bằng lateinit (late initialization) keyword. Ví dụ 1: property được khởi tạo thông qua dependency injection hoặc trong setup() của unit test. Chúng ta có thể sử dụng lateinit để khai báo biến: 1234567891011public class MyTest &#123; lateinit var subject: TestSubject @SetUp fun setup() &#123; subject = TestSubject() &#125; @Test fun test() &#123; subject.method() // dereference directly &#125;&#125; Khi dùng lateinit chúng ta cần tuân theo các quy định sau: 1, Chỉ được dùng với var tạo thành lateinit var cho property ở trong class body. 2, Không được dùng trong constructor và method. 3, Chỉ dùng cho các property không có custom getter và setter. 4, Chỉ dùng cho các property không null và không phải là primitive type. Nếu truy cập lateinit var property trước khi nó được khởi tạo, chúng ta sẽ gặp exception. Do đó, để tránh exception chúng ta nên xác định xem lateinit var property đã được khởi tạo chưa. Để xác định lateinit var property đã được khởi tạo chưa, chúng ta sử dụng isInitialized như sau: 1234567lateinit var bar: Barfun test() &#123; if (::bar.isInitialized) &#123; println(foo.bar) &#125;&#125; II, Lazy variable Đôi khi chúng ta muốn member variable được khởi tạo khi chúng ta cần dùng đến nó. Trong trường hợp như vậy chúng ta có thể sử dụng lazy property thông qua lazy(). lazy() là 1 function có tham số là 1 lambada và trả về 1 Lazy object: Lần đầu tiên gọi get() của property thì biểu thức lambada của lazy() sẽ được xử lý, khởi tạo và ghi nhớ giá trị cho property đó. Các lần gọi get() tiếp theo, property sẽ lấy giá trị được ghỉ nhớ đó (không cần thực hiện lại lambada). Ví dụ 2: Lần đàu tiên sử dụng name, lambada được xử lý do đó name = It life, đồng thời giá trị được ghỉ nhớ. Các lần sử dụng name tiếp theo thì vẫn có giá trị là It life: 123public class Test&#123; val name: String by lazy &#123; “It life” &#125;&#125; lazy() chỉ dùng cho các val property.","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"}]},{"title":"Tìm hiểu về null safety trong kotlin","slug":"null-safety-in-kotlin","date":"2020-07-01T14:21:52.000Z","updated":"2020-07-03T22:55:38.672Z","comments":false,"path":"2020/07/01/null-safety-in-kotlin/","link":"","permalink":"https://fs-sournary.github.io/2020/07/01/null-safety-in-kotlin/","excerpt":"","text":"I, Nullable type Một trong những vấn đề hay gặp phải nhất với các programming language (bao gồm cả java) là sử dụng 1 null variable (reference) sẽ gây ra null reference exception. Trong java, bạn sẽ gặp phải NullPointerException hay NPE. Kotlin cung cấp các công cụ để giúp bạn loại bỏ vấn đề trên trong code. Do đó kotlin sẽ gặp phải NPE ở 1 trong các trường hợp sau: 1, Bạn trực tiếp gọi throw NullPointerException(). 2, Sử dụng toán tử !! trên 1 null reference (mình sẽ nói sau). 3, Gặp vấn đề khi sử dụng platform type hoặc do java code. Ví dụ: add null element vào MutableList&lt;String?&gt;. 4, Liên quan tới việc khởi tạo của 1 object. Kotlin giúp chúng ta phân biệt nullable reference và non-nullable reference. Ví dụ 1: 123var a: String = \"abc\" // Regular initialization means non-null by defaulta = null // compilation errorval l = a.length // ok because it is safe because a isn't nullable Ví dụ 2: 123var b: String? = \"abc\" // can be set nullb = null // okval l = b.length // compilation error because b is nullable II, Check điều kiện null Cách xử lý thông thường giống với java là chúng ta sẽ check xem b có null hay không. Ví dụ 3: nếu b khác null thì gán l = b.length không thì l = -1 1val l: Int = if (b != null) b.length else -1 III, Safe call Kotlin cung cấp 1 công cụ khác là safe call, nó thêm ?. vào sau variable. Ví dụ 4: 12345val a = \"Kotlin\"val b: String? = nullval l: Int? = b.length // b is nullable so l is also nullable.println(b?.length) // need safe call because b is nullableprintln(a?.length) // Unnecessary safe call because a isn't nullable Safe call chain có dạng là v1?.v2?.v3[?.v4[?..]]. Nó rất hữu ích vì nó sẽ return null nếu bất cứ variable nào bị null. Ví dụ 5: Nếu parent, parent.child1 hay parent.child1.child2 return null, safe call chain cũng sẽ return null 1parent?.child1?.child2?.child3 Trong phép gán =, safe call có thể được đặt bên trái của =. Nếu 1 variable trong safe call chain return null, việc gán sẽ bị bỏ qua và biểu thức bên phải = sẽ không được gọi. Ví dụ 6: Nếu person hay person.department trả về null, managersPool.getManager() sẽ không được gọi, do đó việc gán bị bỏ qua 1person?.department?.head = managersPool.getManager() IV, Toán tử Elvis Kotlin cũng cung cấp 1 toán tử khác đó là evils, nó được viết là ?:. Nếu expression bên trái của evils khác null, kết quả của evils là expression bên trái đó. Nếu không, kết quả của evils là expression bên phải. Ví dụ 7: Viết lại ví dụ 3 bằng toán tử evils 1val l = b?.length ?: -1 Trong kotlin, return và thrown cũng là các expression, do đó chúng có thể được dùng trong expression bên phải của evils. Ví dụ 8: 12val parent = node.getParent() ?: return nullval name = node.getName() ?: throw IllegalArgumentException(\"name expected\") V, Toán tử !! Toán tử !! không được khuyến khích vì nó xác nhận rằng variable không thể bị null (mặc dù variable vẫn có thể bị null) và sẽ throw NPE khi variable bị null. Ví dụ 9: nếu b có giá trị null thì code sẽ throw NPE 1val l = b!!.length VI, Safe cast Toán tử cast có thể gây ra ClassCastException nếu kiểu dữ liệu của variable không thuộc kiểu của class được cast. Kotlin cung cấp safe cast, nó được viết là as?. Safe cast sẽ trả về null nếu việc cast không thành công. Ví dụ 10: nêu cast không thành công thì i sẽ có giá trị null 1val i: Int? = a as? Int V, Null type trong các collection Nếu bạn sử dụng collection cho phép các nullable element, bạn có thể lọc để chọn ra những toán tử khác null bằng filterNotNull(). Ví dụ 11: kết quả của nonNullNumbers là [1, 2, 4] 123val numbers: List&lt;Int?&gt; = listOf(1, 2, null, 4)val nonNullNumbers = numbers.filterNotNull()println(nonNullNumbers)","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"}]},{"title":"Tìm hiểu về var, val và const keyword trong Kotlin","slug":"var-val-and-const-in-kotlin","date":"2020-07-01T13:36:50.000Z","updated":"2020-07-03T22:56:03.958Z","comments":false,"path":"2020/07/01/var-val-and-const-in-kotlin/","link":"","permalink":"https://fs-sournary.github.io/2020/07/01/var-val-and-const-in-kotlin/","excerpt":"","text":"I, var và val Để khai báo property trong Kotlin, thông thường chúng ta có thể sử dụng: var: mutable property là thuộc tính có thể thay đổi gía trị. val: immutable property là thuộc tính không thể thay đổi giá trị. val có thể khai báo property ở cả compile time và runtime. II, val vs const const chỉ cho phép read-only property gán giá trị ở compile time. Do đó, các const property còn được biết đến như compile-time constant. Các const property phải tuân theo những quy định sau: 1, Là top-member hoặc property của object class hoặc companion object class. 2, Chỉ được sử dụng để khởi tạo String và primitive type. 3, Không có custom getter.","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"}]},{"title":"Tìm hiểu về String, StringBuilder và StringBuffer","slug":"string-stringbuilder-and-stringbuffer","date":"2020-07-01T12:06:58.000Z","updated":"2020-07-02T12:46:44.191Z","comments":false,"path":"2020/07/01/string-stringbuilder-and-stringbuffer/","link":"","permalink":"https://fs-sournary.github.io/2020/07/01/string-stringbuilder-and-stringbuffer/","excerpt":"","text":"I, String String là 1 final class đại diện cho 1 array các character. Do đó String là immutable object có nghĩa là khi 1 String được khởi tạo, nó không thể thay đổi được nữa. Chúng ta có thể khởi tạo 1 String theo 2 cách: 123String str = \"ABC\";// or String str = new String(\"ABC\"); Ở cách đầu tiên, JVM sẽ tìm hiếm 1 String trong String pool. Nếu tìm thấy, JVM sẽ sử dụng String trong String pool. Nếu không tìm thấy, JVM sẽ tạo ra String object trong String pool. Ở cách thứ hai, JVM tạo ra String object ở trong heap memory. String class override 2 method equals() và hashCode(). Implement của equals() trong String class return true nếu chúng có cùng mảng character. II, StringBuilder và StringBuffer Vì String là immutable object do đó các method của String chỉ tạo và trả về 1 String mới. Các method này sinh ra nhiều rác trong heap memory. Do đó chúng ta nên sử dụng StringBuilder và StringBuffer để làm việc với String. StringBuffer StringBuilder Thread-safe Not thread-safe Synchronized Not synchronized Được thêm từ Java 1.0 Được thêm từ Java 1.5 Slower Faster Toán tử + nội tại sử dụng StringBuilder và StringBuffer. Do StringBuffer thực hiện synchronized (thread-safety) do đó nó chậm hơn StringBuilder. StringBuilder và StringBuffer chỉ tạo ra 1 String khi bạn gọi toString().","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"},{"name":"Java","slug":"Java","permalink":"https://fs-sournary.github.io/tags/Java/"}]},{"title":"Tìm hiểu về nested class","slug":"nested-class","date":"2020-07-01T11:07:06.000Z","updated":"2020-07-02T12:50:33.196Z","comments":false,"path":"2020/07/01/nested-class/","link":"","permalink":"https://fs-sournary.github.io/2020/07/01/nested-class/","excerpt":"","text":"I, Nested class Java/Kotlin cho phép bạn định nghĩa 1 class nằm trong 1 class khác. Những class nằm trong 1 class khác gọi là nested class. Nested class chia làm 2 loại: static nested class và inner class (non-static nested class). 123456789class OuterClass &#123; ... static class StaticNestedClass &#123; ... &#125; class InnerClass &#123; ... &#125;&#125; II, Inner class Bởi vì inner class liên kết với 1 instance của outer class nên nó có thể truy cập các member khác của outer class ngay cả khi chúng khai báo với private. Vì nó liên kết với 1 instance của outer class nên nó không thể chứa bất kì static member nào. 1234567891011121314public class OuterClass &#123; private int index = 0; class InnerClass &#123; // Compiler error do inner class không được chứa bất cứ static member nào // static int i = 1; void test()&#123; System.out.println(\" \" + index); &#125; &#125;&#125; Một instance của inner class chỉ có thể tồn tại khi có 1 outer class. 12OuterClass outerClass = new OuterClass();OuterClass.InnerClass innerClass = outerClass.new InnerClass(); III, Static nested class Giống như static member khác, static nested class liên kết với class chứa nó (không phải liên kết với instance). Do đó, nó không thể sử dụng các member của class chứa nó. static nested class có behavior giống như top-level class. Bạn có thể khởi tạo nó mà không cần đến instance của class chứa nó: 1OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"},{"name":"Java","slug":"Java","permalink":"https://fs-sournary.github.io/tags/Java/"}]},{"title":"Tìm hiểu về static trong Java","slug":"static-keyword","date":"2020-07-01T10:33:13.000Z","updated":"2020-07-03T22:15:16.839Z","comments":false,"path":"2020/07/01/static-keyword/","link":"","permalink":"https://fs-sournary.github.io/2020/07/01/static-keyword/","excerpt":"","text":"I, static keyword static keyword có thể được dùng với: block: static block. variable: static variable. method: static method. nested class: static nested class. static member sẽ gắn với class của nó (không phải gắn với instance). Do đó, bạn có thể truy cập chúng mà không cần instance. II, static block Khi static variable chưa được gán giá trị, bạn có thể gán giá trị của nó ở trong static block. Static block chỉ xử lý 1 lần khi class load lần đầu. Ví dụ 1 12345678910111213141516class TestBlock &#123; static int a = 10; static int b; static &#123; System.out.println(\"Static block initialized.\"); b = a * 4; &#125; public static void main(String[] args) &#123; System.out.println(\"from main\"); System.out.println(\"Value of a : \"+ a); System.out.println(\"Value of b : \"+ b); &#125; &#125; kết quả là: 1234Static block initialized.from mainValue of a : 10Value of b : 40 III, static variable Static variable gắn với class của nó (không phải là instance). Điều này có nghĩa nếu bạn định nghĩa static variable, tất cả các instance của class dùng chung 1 static member (thay vì mỗi instance có 1 static member). Khi bạn thay đổi giá trị của static variable thì những lời gọi sau này tới static member đó cũng sẽ nhận được gía trị mới nhất đó. IV, static method Static method được gọi mà không cần phải khỏi tạo object. Nó giúp tối ưu hoá performance thường được sử dụng cho các util method. Nếu method của bạn không liên quan tới member variable của class thì nên sử dụng static method. Tuy nhiên, static method cũng có một số nhược điểm sau: 1, Chỉ có thể gọi static method khác. 2, Chỉ có gọi những static variable (class variable). 3, Không cho phép this() hay super(). Đây cũng là lý do class con không thực sự override static method của class cha. Ví dụ 2: 123456789101112131415161718192021class TestMethod &#123; int b = 20; // instance variable static int a = 10; // static variable // static method static void test() &#123; a = 20; // Cannot make a static reference to the non-static field b b = 10; // compilation error // Cannot make a static reference to the // non-static method m2() from the type Test m2(); // compilation error // Cannot use super in a static context System.out.println(super.a); // compiler error &#125; &#125; V, static nested class Bạn có thể tham khảo ở bài viết về nested class","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://fs-sournary.github.io/tags/Java/"}]},{"title":"Tìm hiểu về equals() và hashCode()","slug":"equals-and-hashcode","date":"2020-07-01T07:54:12.000Z","updated":"2020-07-03T22:14:20.476Z","comments":false,"path":"2020/07/01/equals-and-hashcode/","link":"","permalink":"https://fs-sournary.github.io/2020/07/01/equals-and-hashcode/","excerpt":"","text":"I, Phương thức equals()1, Lý thuyết Như bài viết trước so sánh == và equals(), mình cũng đã nói qua về phương thức equals(). Phương thức equals() được dùng để kiểm tra 1 object có equal to với object khác không. Nó được thực thi theo hai cách: Shallow comparison: mặc định, equals() được định nghĩa trong Object class, nó kiểm tra 2 variable có cùng trỏ tới 1 object hay không (tương đương với x == y). Điều này bởi vì Object không có property nào để định nghĩa state. Deep comparison:: class có các property và tiến hành implement equals() method dựa trên các property đó. Ví dụ như Integer, String… 123456789// Shallow comparisonpublic class Object &#123; // Not have any member variable to define its state. public boolean equals(Object obj) &#123; return (this == obj); &#125;&#125; 123456789101112// Deep comparisonpublic final class Integer extends Number implements Comparable&lt;Integer&gt; &#123; private final int value; public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false; &#125;&#125; Chú ý: Nếu class không implement equals() method, equals() của class đó sẽ là của class cha implement equals() gần nó nhất. 2, Ví dụ Ví dụ 1: shallow comparison không override equals() method 12345678class Test &#123; public int val; public Test(int val)&#123; this.val = val; &#125;&#125; 12345678class TestComparator()&#123; public static void main(String args[])&#123; Test a = new Test(1000); Test b = new Test(1000); a.equals(b) // return false mặc định equals() cũng so sánh memory address (của Object class) như ==. &#125;&#125; Ví dụ 2: deep comparison override equals() method 12345678910111213class Test &#123; private int val; public Test(int val)&#123; this.val = val; &#125; // Deep comparison public boolean equals(Test b)&#123; return this.val == b.val &#125;&#125; 12345678class TestComparator()&#123; public static void main(String args[])&#123; Test a = new Test(1000); Test b = new Test(1000); a.equals(b) // return true. &#125;&#125; II, Phương thức hashCode() Phương thức hashCode() trả về 1 giá trị int. Gía trị hashCode được sử dụng phần lớn trong Collection sử dụng cơ chế hashing như HashMap, HashSet, HashTable… Một class override equals() thì class cũng nên override hashCode(). Một số lưu ý khi override hashCode(): Nếu x và y có equals() return true, hashCode() cũng phải trả về cùng 1 int trên cả x và y. Nếu x và y có equals() return false, hashCode() không nhất thiết phải trả về 2 int khác nhau. Chúng có thể giống nhau nhưng trả về 2 int khác nhau sẽ giúp tăng performance cho các collection sử dụng cơ chế hashing.","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"},{"name":"Java","slug":"Java","permalink":"https://fs-sournary.github.io/tags/Java/"}]},{"title":"Tìm hiểu về == và equals()","slug":"equal-operator-and-equals-method","date":"2020-07-01T03:53:16.000Z","updated":"2020-07-02T14:04:05.597Z","comments":false,"path":"2020/07/01/equal-operator-and-equals-method/","link":"","permalink":"https://fs-sournary.github.io/2020/07/01/equal-operator-and-equals-method/","excerpt":"","text":"I, So sánh == vs equals() Toán tử == dùng để so sánh memory address: hai biến có trỏ tới cùng 1 object trên memory (heap memory, string pool…) hay không. Phương thức equals() có hai kiểu so sánh: Shallow comparison: mặc định equals() có implement của Object, nó trả về true khi và chỉ khi 2 biến x và y cùng trỏ tới 1 object (x == y return true). Điều này là bởi vì Object không có property nào để định nghĩa state. Deep comparison: class có các property và tiến hành implement equals() dựa trên các property đó. Với các class như Integer, String… equals() đã thực hiện deep comparison tức là các class đó đã tiến hành implement equals() dựa trên so sánh các property của chúng. Chú ý: Nếu 1 class không implement equals() method, equals() của class đó sẽ thừa hưởng từ class cha gần nhất implement equals() method. Ví dụ 1: source code implement equals() method (shallow comparison) trong Object class 123public boolean equals(Object obj) &#123; return (this == obj);&#125; Ví dụ 2: source code implement equals() method (deep comparison) trong 2 class Integer và String 1234567// Integer.javapublic boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false;&#125; 1234567891011121314151617181920// String.javapublic boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = length(); if (n == anotherString.length()) &#123; int i = 0; while (n-- != 0) &#123; if (charAt(i) != anotherString.charAt(i)) return false; i++; &#125; return true; &#125; &#125; return false;&#125; II, Deep comparison Với api object như Integer, String… đã implement equals() method. Chúng thực hiện có deep comparison như mình đã nói ở trên. Ví dụ 3: 12345678int a = 1000;Integer b = 1000;Integer c = new Integer(1000);a == b // true bởi vì java có cơ chế autoboxing và unboxing nên khi so sánh b sẽ bị unboxing về int.b == c ? // false bởi vì b và c trỏ tới 2 object khác nhau trên heap.b.equals(a) ? // true bởi vì b và a cùng giá trị 1000.c.equals(b) ? // true vì b và c cùng giá trị 1000. Ví dụ 4: 12345678String a = \"abc\";String b = \"abc\";String c = new String(\"abc\");a == b // true bời vì a và b được tạo từ String literals trong String pool trên heap nên chúng sẽ trỏ tới cùng 1 object.b == c // false bởi vì toán tử new tạo ra 1 object khác không nằm trong String pool trên bộ nhớ heap.a.equals(b) // true bởi vì a và b có cùng giá trị.c.equals(b) // true bởi vì a và b có cùng giá trị. III, Shallow comparison Đối với class tự định nghĩa, nếu không implement equals() thì class đó sẽ lấy implement của Object class. Chúng thực hiện shallow comparison. Ví dụ 5: shallow comparison không override equals() method 123456789101112131415161718class Test &#123; public int val; public Test(int val)&#123; this.val = val; &#125;&#125;class TestComparator()&#123; public static void main(String args[])&#123; Test a = new Test(1000); Test b = new Test(1000); a == b // return false bởi vì a và b trỏ đến 2 object khác nhau. a.equals(b) // return false mặc định equals() cũng so sánh memory address như ==. &#125;&#125; Ví dụ 6: deep comparison override equals() method 1234567891011121314151617181920212223class Test &#123; private int val; public Test(int val)&#123; this.val = val; &#125; // Deep comparison public boolean equals(Test b)&#123; return this.val == b.val &#125;&#125;class TestComparator()&#123; public static void main(String args[])&#123; Test a = new Test(1000); Test b = new Test(1000); a == b // return false bởi vì a và b trỏ đến 2 object khác nhau. a.equals(b) // return true. &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://fs-sournary.github.io/tags/Java/"}]},{"title":"Tìm hiểu về transient","slug":"transient-keyword","date":"2020-07-01T03:21:57.000Z","updated":"2020-07-03T22:18:15.472Z","comments":false,"path":"2020/07/01/transient-keyword/","link":"","permalink":"https://fs-sournary.github.io/2020/07/01/transient-keyword/","excerpt":"","text":"I, Transient keyword Từ khoá transient key trong Java hay @Transient trong kotlin dùng cho các property, các property sẽ không được áp dụng quá trình serialization ( quá trình convert object thành 1 dòng byte và lưu vào file). II, Ví dụ Ví dụ 1: Bạn có Student có 3 property: id, name và age. Khi 1 instance của Student tiến hành quá trình serialization, bạn muốn age bị bỏ qua trong quá trình đó 123456789101112public class Student implements Serializable &#123; private int id; private String name; private transient int age; //Now it will not be serialized public Student(int id, String name,int age) &#123; this.id = id; this.name = name; this.age=age; &#125; &#125; Tiếp theo, chúng ta viết code thực hiện quá trình serialization để convert object thành 1 dòng byte và lưu vào file: 12345678910111213class PersistExample&#123; public static void main(String args[])&#123; Student s1 = new Student(211, \"ravi\", 22); //writing object into file FileOutputStream f = new FileOutputStream(\"f.txt\"); ObjectOutputStream out = new ObjectOutputStream(f); out.writeObject(s1); out.flush(); out.close(); f.close(); &#125; &#125; Cuối cùng, chúng ta thực hiện quá trình de-serialization để phục hồi object từ file và in ra dữ liệu của object đó: 123456789class DePersist&#123; public static void main(String args[])&#123; ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"f.txt\")); Student s = (Student)in.readObject(); System.out.println(s.id + \" \" + s.name + \" \" + s.age); in.close(); &#125; &#125; Chúng ta đánh dấu age là 1 transient variable nên nó sẽ không được serialize vào file. Do đó chúng ta có kết quả: 1211 ravi 0","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"},{"name":"Java","slug":"Java","permalink":"https://fs-sournary.github.io/tags/Java/"}]},{"title":"Tìm hiểu về Serializable và Parcelable","slug":"serialization-and-deserialization","date":"2020-07-01T01:22:11.000Z","updated":"2020-07-02T14:20:32.507Z","comments":false,"path":"2020/07/01/serialization-and-deserialization/","link":"","permalink":"https://fs-sournary.github.io/2020/07/01/serialization-and-deserialization/","excerpt":"","text":"I, Serializable Quá trình serialization là quá trình chuyển đổi 1 object thành 1 luồng byte để lưu trữ vào trong bộ nhớ. Quá trình de-serialization là quá trình ngược của serialization, nó sử dụng các byte trong bộ nhớ để phục hồi lại object. Các byte được serialize không phụ thuộc vào nền tảng nào cả. Do đó, 1 object có thể serialize trên 1 nền tảng và de-serialize trên 1 nền tảng khác. Lợi ích của sử dụng quá trình serialization: 1, Lưu giữ state và data của object. Do đó, object có thể phục hồi sau này. 2, Có thể truyền 1 object sử dụng quá trình serialization qua network. Trong java, chúng ta có thể thực hiện quá trình serialization thông qua Serializable interface. Một số điểm lưu ý khi sử dụng Serializable: 1, Nếu parent class implement Serializable interface thì child class không cần phải implement nó. 2, Chỉ có non-static và non-transient variable có thể thực hiện quá trình serialization. 3, Do static variable và transient variable không thực hiện được quá trình serialization do đó nếu bạn không muốn lưu trữ dữ liệu của non-static variable thì đánh dấu nó là transient. 4, Constructor của object không được gọi khi object được phục hồi bằng de-serialization. 5, Serialization sử dụng quá trình reflection. II, Parcelable Để tối ưu hoá, Android sử dụng Binder để tạo điều kiện giao tiếp giữa các component và Binder kết nối với Parcel là message container. Inteface Parcelable là 1 interface dùng để truyền dữ liệu giữa các component trong Android. Khi thực hiện truyền dữ liệu, các state và data của object sẽ được lưu vào trong 1 Parcel. Sử dụng Parcelable nhanh gấp nhiều lần so với Serializable nhưng việc triển khai trong Java khá dài dòng.1, Java 1234567891011121314151617181920212223242526public class MyParcelable implements Parcelable &#123; private int mIndex; public int describeContents() &#123; return 0; &#125; public void writeToParcel(Parcel out, int flags) &#123; out.writeInt(mIndex); &#125; public static final Parcelable.Creator&lt;MyParcelable&gt; CREATOR = new Parcelable.Creator&lt;MyParcelable&gt;() &#123; public MyParcelable createFromParcel(Parcel in) &#123; return new MyParcelable(in); &#125; public MyParcelable[] newArray(int size) &#123; return new MyParcelable[size]; &#125; &#125;; private MyParcelable(Parcel in) &#123; mIndex = in.readInt(); &#125; &#125; Bạn cần override và implement các method và class: writeToParcel(): method ghi state và data của object vào trong 1 Parcel. CREATOR: static variable dùng để phục hồi lại object từ Parcel. 2, Kotlin Kotlin giúp bạn override các method và class trên. Bạn chỉ cần làm như sau: 1234// Add in build.gradle in the app level.androidExtensions &#123; experimental = true&#125; 123// Just add @Parcelize annotation and implement Parcelable interface.@Parcelizedata class MyParcelable(val index: Int) : Parcelable III, So sánh giữa Serializable and Parcelable Serializable Parcelable Dễ triển khai Trong java, tốn nhiều mã nguồn để triển khai. Có thể sử dụng ở nhiều nền tảng Chỉ dành riêng cho Android Chậm và sinh ra nhiều rác Nhanh hơn Có thể truyền qua network Không thể truyền qua network.","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"},{"name":"Java","slug":"Java","permalink":"https://fs-sournary.github.io/tags/Java/"}]},{"title":"Tìm hiểu về Exception","slug":"exception","date":"2020-06-30T09:41:14.000Z","updated":"2020-07-02T14:30:45.045Z","comments":false,"path":"2020/06/30/exception/","link":"","permalink":"https://fs-sournary.github.io/2020/06/30/exception/","excerpt":"","text":"I, Mở đầu Exception là một sự kiện thường gặp trong khi tạo ra chương trinh. Trong bài viết này, mình sẽ trình bày rõ hơn exception, hệ thống phân cấp và cơ chế JVM xử lý các exception. II, Định nghĩa vầ phân cấp Exception là sự kiện làm phá vớ luồng thực thi của chương trình. Nếu chúng ta không xử lý các exception, Thread hiện tại là: Main Thread: chương trình sẽ bị chết. Không phải là main Thread: Thread sẽ bị ngắt. Trong phân cấp exception thì Throwable class ở mức cao nhất. Hai class con kế thừa Throwable là Error và Exception. Chúng ta có thể chia exception thành 2 loại: Unchecked exception: bao gồm Error và RuntimeException. Checked exception: các loại exception khác. 1, Checked exception Checked exception hay còn gọi là compile time exception bời vì chúng xảy ra ở compile time. Thông thường khi bạn compile chương trình nếu có checked exception, IDE sẽ thông báo cho chúng ta biết ngay. Như mình đã nói ở trên tất cả các class kế thừa Exception class ngoại trừ RuntimeException đều là checked exception. Các checked exception chúng ta hay gặp: FileNotFoundException, IOException… 2, Unchecked exception Unchecked exception hay còn gọi là runtime exception bởi vì chúng bị bỏ qua trong compile time và chỉ xảy ra ở runtime. Chúng thường xảy ra do bug, logic… của chương trình cũng có thể do môi trường của ứng dụng. Do đó chúng khó bị phát hiện và fix hơn. Các class kế thừa Error và RuntimeException đều là unchecked exception. Các unchecked exception chúng ta hay gặp: NullPointerException, ArrayIndexOutOfBoundException, NumberFormatException… III, Cơ chế JVM xử lý các Exception Exception Handling là cơ chế xử lý các exception ở runtime để có thể duy trì luồng thực thi của chương trình. Exception Handling được thực hiện bằng try/catch block. Nếu trong try block xảy ra Exception, code trong try sẽ không được thực thi nữa. JVM sẽ tìm kiếm catch block có xử lý Exception đó. Nếu không có catch block hay catch block không xử lý đúng Exception bị throw, code thực thi finally block và ngắt Thread hiện tại. Nếu catch block xử lý đúng Exception, code tiếp tục thực thi đến khi hết catch, sau đó finally thực thi Thread như thông thường. IV, Một số lưu ý Khi code trong try block throw Exception, các catch sẽ được check theo thứ tự thực thì. Khi 1 catch block đã được thực thi, các catch block theo sau sẽ bị bỏ qua. Các catch nên được sắp xếp để xử lý theo thứ từ Exception con tới Exception cha. Ví dụ: chúng ta nên catch NumberFormatException trước khi catch Exception. Khối finally luôn được thực hiện dù Exception có được catch hay không. Nó sẽ không được thực thi khi System.exit() được gọi hay Error mà môi trường không xử lý được xảy ra. Đối với mỗi try block, có thể không có hoặc có 1 hoặc nhiều catch block nhưng sẽ chỉ có 1 finally block.","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"},{"name":"Java","slug":"Java","permalink":"https://fs-sournary.github.io/tags/Java/"}]},{"title":"Tìm hiểu về synchronized","slug":"synchronized-keyword","date":"2020-06-30T08:43:23.000Z","updated":"2020-07-03T22:16:38.310Z","comments":false,"path":"2020/06/30/synchronized-keyword/","link":"","permalink":"https://fs-sournary.github.io/2020/06/30/synchronized-keyword/","excerpt":"","text":"I, Lời mở đầu Nếu bạn chưa đọc về volatile, mình khuyên bạn nên tìm hiểu trước về keyword này trước. Trong Java/kotlin, chúng ta có thể đã sử dụng qua synchronized keyword. Vâỵ thực sự nó có ý nghĩa gì và thường áp dụng vào trong trường hợp nào ? Hôm nay mình sẽ nói cụ thể hơn về keyword này. II, Ý nghĩa và use cases Cớ chế synchronized có thể được sử dụng như synchronized() function hay Synchronized annotation. Trong multiple thread application, việc đọc và ghi có thể bị cản trở bởi 1 vài lý do như switching, file handler… Cơ chế synchronized đâm bảo rằng việc đọc và viết các variable, object hay thực hiện các function không bị cản trở. Trong Sun document, họ cũng đã nói rõ về keyword này: synchronized methods enable a simple strategy for preventing thread interference and memory consistency errors: if an object is visible to more than one thread, all reads or writes to that object’s variables are done through synchronized methods. Ví dụ: 1234567class SynchronizedDemo &#123; @Volatile @Synchronized private var index: Int = 0&#125; Trong ví dụ trên, index được annotate bằng volatile keyword có nghĩa là index sẽ visible với các Thread dùng tới nó. Nhưng không có gì đảo rằng việc đọc và ghi index trên các Thread khác nhau không bị cản trở và có thể bị error. Khi bạn sử dụng @Synchronized annotation, nó sẽ đảm bảo các cản trở đó sẽ không bị diễn ra. Do đó nó sẽ an toàn (thread-safe) khi sử dụng multiple thread. Mình hay kết hợp volatile và synchronized để implement Singleton pattern.","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"},{"name":"Java","slug":"Java","permalink":"https://fs-sournary.github.io/tags/Java/"}]},{"title":"Tìm hiểu về volatile keyword","slug":"volatile-keyword","date":"2020-06-30T03:14:24.000Z","updated":"2020-07-03T22:21:38.848Z","comments":false,"path":"2020/06/30/volatile-keyword/","link":"","permalink":"https://fs-sournary.github.io/2020/06/30/volatile-keyword/","excerpt":"","text":"I, Mở đầu Trong Java/kotlin, mọi người có thể để ý thấy từ khoá volatile. Từ khoá volatile được sử dụng với property và đánh dấu chúng được lưu trữ trong main memory: Read: volatile property đọc từ main memory sang 1 CPU cache. Write: volatile property viết từ CPU cache sang main memory. Khi volatile property thay đổi trên 1 Thread thì các Thread khác cũng sẽ biết sự thay đổi đó. Nói cách khác variable đã visible trên các Thread khác. II, Variable visibility problem Các non-volatile variable không được read and write tới main memory. volatile giúp developer giải quyết được visibility problem trong multiple thread application: update propery trên 1 Thread nhưng các Thread khác không có được update đó. Nghe có vẻ hơi trừu tượng, chúng ta sẽ tìm hiểu thông qua ví dụ dưới đây. Ví dụ 1: chúng ta có 2 Thread có quyền truy cập vào SharedObject: 12345public class SharedObject &#123; public int counter = 0;&#125; Nếu ở Thread 1, counter gán bằng 7 nhưng Thread 2, counter vẫn bằng 0. Vấn đề ở đây là Thread 2 đã không nhìn thấy giá trị mới nhất của counter bởi vì nó không được write vào trong main momory. Đó cũng chính là visibility problem. Ví dụ 2: tương tự như ví dụ 1 nhưng chúng ta sẽ thêm volatile keyword cho counter: 12345public class SharedObject &#123; public volatile int counter = 0;&#125; Nếu ở Thread 1, counter gán bằng 7 sau đó Thread 2 đọc giá trị của counter cũng sẽ là 7. Trong Java/kotlin, người ta thường sử dụng volatile keyword để implement singleton pattern.","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"},{"name":"Java","slug":"Java","permalink":"https://fs-sournary.github.io/tags/Java/"}]},{"title":"Implement design pattern trong Android với Kotlin phần I","slug":"android-design-pattern-part-I","date":"2020-06-28T02:43:12.000Z","updated":"2020-07-02T14:42:25.158Z","comments":false,"path":"2020/06/28/android-design-pattern-part-I/","link":"","permalink":"https://fs-sournary.github.io/2020/06/28/android-design-pattern-part-I/","excerpt":"","text":"I, Lời mở đầu Điều gì quyết định đến chất lượng code của bạn ? Chất lượng code được quyết định từ nhiều yếu tố như coding convention, comments, code structure… Coding convention: giúp các developer viết code theo đúng quy chuẩn của một ngôn ngữ. Comment: giúp bạn và những developer khác hiểu rõ hơn đoạn code của bạn đang thực hiện tác vụ gì. Bài viết này mình đến đó chính là design pattern. Android cũng đã cung cấp các công cụ (Jetpack, di, coroutine…) giúp các developer thực hiện Architecture component. Awesome !!! Để code của bạn trở nên chuyên nghiệp, dễ hiểu và ngắn gọn, mình khuyên mọi người nên áp dụng cả design pattern vào trong code của mình. II, Design pattern là gì Design pattern là một giải pháp chung để giải quyết những vấn đề thông thường trong một số trường hợp nhất định. Những lợi ích của việc sử dụng design pattern: Code dễ hiểu: bởi vì bạn theo những guildline, quy tắc chuẩn nên các developer khác khi đọc code sẽ dễ dàng hiểu được bạn đang làm gì. Ví dụ như khi bạn sử dụng singleton pattern, mọi người sẽ hiểu bạn muốn tạo ra 1 instance duy nhất trong ứng dụng của mình. Code dễ dàng tái sử dụng: Bạn có thể thực hiện 1 task vụ nhiều lần, áp dụng design pattern bạn sẽ giảm được việc lặp đi lặp lại đoạn code của minh. Code sạch hơn: design pattern làm cho code của bạn trở nên ngắn gọn và module hoá hơn. Trong software design, chúng ta có thể chia design pattern ra làm 3 nhóm: Creational pattern. Structural pattern. Behavior pattern. Phần đầu tiên, mình sẽ giới thiệu nhóm đầu tiên và cũng phổ biến nhất: creational pattern. III, Creational pattern Creational pattern được sử dụng để tạo những object mà không đòi hỏi bạn phải show ra logic hay các step để tạo ra object đó. Do đó, mỗi lần bạn tạo ra 1 đối tượng, bạn không cần phải khởi tạo đối tượng thông qua việc sử dụng new operator nữa. Mỗi ngôn ngữ hay system áp dụng design pattern một cách khác nhau. Nhóm creational có rất nhiều cách implement tuỳ thuộc vào tình huống. Mình sẽ đưa ra 3 pattern phổ biến nhát implement creational pattern: singleton pattern, dependency injection pattern và builder pattern. 1, Singleton pattern Singleton pattern được sử dụng khi bạn muốn thực hiện 1 nhóm các tác vụ một lần. Do đó trong ứng dụng chỉ có một instance được tạo ra và nó gắn với vòng đời của ứng dụng. Singleton pattern thường được sử dụng trong các trường hợp: logging, database creation, thread pool… Ví dụ: Với mỗi database, bạn chỉ cần tạo ra 1 Room instance duy nhất trong toàn bộ ứng dụng. Singleton pattern rất được ưu ái, được Kotlin hỗ trợ việc implement thông qua việc sử dụng object class và companion object class. Trong kotlin, object class và companion object có một số đặc điểm đáng chú ý sau: Không có contructor method. Có thể có init{}, variables và functions. Có thể extend 1 class khác nhưng không thể để class khác kế thừa. Ví dụ: 12345678910111213141516171819202122232425262728object Singleton &#123; init &#123; println(\"Singleton class invoked.\") &#125; var variableName = \"I am Var\" fun printVarName()&#123; println(variableName) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; Singleton.printVarName() Singleton.variableName = \"New Name\" var a = A()&#125;class A &#123; init &#123; println(\"Class init method. Singleton variableName property : $&#123;Singleton.variableName&#125;\") Singleton.printVarName() &#125;&#125; Do companion object và object class không cho phép tạo constructor, do đó chúng ta không thể truyền tham số vào trong chúng. Trong trường hợp, bạn muốn tạo 1 class implement singletion pattern và có constructor. Bạn hãy làm theo ví dụ sau: 12345678910111213141516171819202122232425class MovieRepository(private val movieDbApi: MovieDbApi, private val genreDao: GenreDao) &#123; // Do functions companion object &#123; // Singletion prevents multiple ínstances. @Volatile private var INSTANCE: MovieRepository? = null fun getInstance(movieDbApi: MovieDbApi, genreDao: GenreDao): MovieRepository &#123; var temp = INSTANCE if(temp != null)&#123; return temp &#125; synchronized(this)&#123; val instance = MovieRepository(movieDbApi, genreDao) INSTANCE = instance return instance &#125; &#125; &#125;&#125; Trong ví dụ, mình muốn tạo ra 1 single instance MovieRepository gắn với class để nó tồn tại trong suốt ứng dụng nên mình đã khai báo INSTANCE trong companion object class. Để có đảm bảo INSTANCE đồng nhất (ngay cả khi multiple thread), bạn phải sử dụng @Volatile. Để không có bất kì ảnh hưởng nào trong quá trình tạo instance, bạn phải sử dụng synchronized(). 2, Dependency injection pattern Chúng ta đều biết rằng hầu hết các class đều cần đến các dependency. Nếu không thực hiện denpendecy injection pattern, thông thường chúng ta sẽ hard-code và khởi tạo dependency trong chính class đó: 123456class Repository &#123; private val database = DatabaseManager() // dependent on DatabaseManager. private val api = NetworkManager() // dependent on NetworkManager.&#125; Vấn đề: bạn thực hiện hard-code như trên ở nhiều nơi sau đó lại muốn thay đổi dependecy đó bằng dependency khác, bạn sẽ phải thay thế ở tất cả mọi nơi có khai báo đó. Do đó chúng ta không nên khởi tạo trực tiếp dependency ở trong 1 class mà hãy cung cấp nó từ bên ngoài. 12345class Repository (private val database: DatabaseManager, private val api: NetworkManager) &#123; // Do functions&#125; Google hỗ trợ chúng ta thực hiện dependecy injection pattern cách sử dụng dagger, hilt… 3, Builder pattern Trong một tác vụ, đôi khi bạn chỉ quan tâm đến một số dữ liệu đầu vào và không quan tâm phần còn lại (có thì càng tốt :grinning:). Trong trường hợp như vậy bạn nên cân nhắc tới việc sử dụng builder pattern. Ví dụ: bạn cần mua 1 cái laptop, trong laptop có nhiều bộ phận nhưng bạn chỉ quan tâm tới: processor. Những bộ phận khác như ram, battery, screen bạn không quan tâm đến. Sau đó, người bán hàng sẽ đưa ra cho bạn mẫu laptop thoả mãn yêu cầu của bạn. Trong lập trình cũng thế, bạn tạo 1 class có nhiều variable, trong đó 1 số tham số là quan trọng và một số khác không quan trọng, hãy cân nhắc tới việc sử dụng builder pattern. Khi bạn thực hiện builder pattern, nó không yêu cầu bạn thực hiện tất cả các method và bạn cũng không cần quan tâm đến thứ tự của các method set. Ví dụ: mình sẽ tạo ra 1 class Laptop theo yêu cầu ở ví dụ trước đưa ra: 12345678910111213141516171819202122232425262728293031323334class Laptop private constructor( val processor: String, val ram: String, val battery: String, val screenSize: String) &#123; // Builder class class Builder(private val processor: String) &#123; // optional features var ram: String = \"2GB\" var battery: String = \"5000MAH\" var screenSize: String = \"15inch\" fun setRam(ram: String): Builder &#123; this.ram = ram return this &#125; fun setBattery(battery: String): Builder &#123; this.battery = battery return this &#125; fun setScreenSize(screenSize: String): Builder &#123; this.screenSize = screenSize return this &#125; fun create(): Laptop = Laptop(processor, ram, battery, screenSize) &#125;&#125; Khi bạn muốn tạo ra 1 instance của Laptop class: 1234Laptop.Builder(\"i5\") .setRam(\"16GB\") .setBattery(\"7000MAH\") .create() Android cũng có rất nhiều class được implement theo builder pattern như AlertDialog… IV, Tổng kết Bạn không cần vội vã học các thứ kiến thức cao siêu đâu. Những thứ căn bản sẽ giúp bạn trở nên tốt hơn đó. Trong lập trình cũng thế, nó đòi hỏi sự tỉ mỉ, kiên trì và sáng tạo nên đi chậm mà chắc nhé sau đó tăng tốc nhé. Qua bài này, chúng ta lại có 1 công cụ mới để kết hợp đó là Architecture component + design pattern. Hẹn mọi người vào bài chia sẻ sau nhé !!!","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://fs-sournary.github.io/tags/Android/"},{"name":"Design pattern","slug":"Design-pattern","permalink":"https://fs-sournary.github.io/tags/Design-pattern/"}]}],"categories":[],"tags":[{"name":"Cấu trúc dữ liệu và giải thuật","slug":"Cau-truc-du-lieu-va-giai-thuat","permalink":"https://fs-sournary.github.io/tags/Cau-truc-du-lieu-va-giai-thuat/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://fs-sournary.github.io/tags/Kotlin/"},{"name":"Java","slug":"Java","permalink":"https://fs-sournary.github.io/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://fs-sournary.github.io/tags/Android/"},{"name":"Design pattern","slug":"Design-pattern","permalink":"https://fs-sournary.github.io/tags/Design-pattern/"}]}